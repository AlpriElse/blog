---
author: Alpri Else
pubDatetime: 2024-01-04T04:00:00.000Z
title: Just get it to work
slug: just-get-it-to-work
featured: true
ogImage: https://user-images.githubusercontent.com/53733092/215771435-25408246-2309-4f8b-a781-1f3d93bdf0ec.png
description: Great Filters and Street Fighting Software Engineering
tags:
  - micro-blog
---

Quite frankly, I have plenty of personal projects that have been left unfinished -- it's all too easy to get caught in the details of every single problem and lost interest and discipline to move the project forward. I ran across this timely video from Joey from BPS who argues for optimizing against some "Great Filter": another label for describing your project's #1 priority or its most devastating failure mode. For projects you work on within the context of a job, this filter is usually optimized against some engineering metric, deadline, or cost. In the worst case, your project runs over Service-level Agreements (SLAs) or you don't meet a deadline leading to features getting de-scoped.

But, for personal projects, your greatest "Great Filter" is finishing your project. While Joey directly thinks of Great Filters through the lens of Personal Projects, its perspective aligns well with the context of building a startup and bringing a new product to market.

<iframe width="560" height="315" src="https://www.youtube.com/embed/4jgTCayWlwc?si=4YFd6elqSyxHpFDH" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Joey focuses on Personal Projects; now working on a product I'm building as a business from scratch, and the same existence filter applies.

In a startup, no one cares you're not using the most scalable framework or that you can't handle 10x the scale. You just need to build something of value and be able to distribute it to people who can pay before you run out of money.

"Street Fighting Mathematics" is a lecture that walks through ways to progress your Computer Science theory research 'the dirty way'.

Before watching this video, I thought CS Theory research was an exercise of memorizing and learning as much CS Theory and math so you can magically peer through patterns to expertly navigate your proof. There's some of that for sure. But, for a lot of theory problems, you don't need to memorize everything. You can brute force subproblems with online tools and just pretend like you knew that obscure piece of math knowledge the whole time when you write your research paper.

<iframe width="560" height="315" src="https://www.youtube.com/embed/qP4XEZ54eSc?si=XbUw4dJPX3AAPUh8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Building software for a new product is similar. You don't need to hand-build a component framework or directly write every SQL query. There are libraries and tools that exist that speed up this process.

There really should be a "Street Fighting Software Engineering" video: a tutorial on all the different APIs, libraries, or other strategies to just quickly fake and prototype ideas without fully committing to building a full, robust technical solution. Coming out of a larger tech company where your impulse might be to just recreate the same familiar tooling and infrastructure you once had, it's an active skill to learn how to be scrappy. But if your Great Filter is having your project just existing at all, you need to fight dirty and just get your prototype working.

You can [use Google Spreadsheet as your primary datastore](https://www.levels.fyi/blog/scaling-to-millions-with-google-sheets.html). Just be [a GPT wrapper before training your own models](https://www.youtube.com/watch?v=z0wt2pe_LZM). You can [Wizard of Oz" your AI](https://en.wikipedia.org/wiki/Wizard_of_Oz_experiment) and you yourself are pretending to be the AI before actually building it. You just don't have time to have the perfect environment, the perfect tooling, the perfect architecture, the perfect CI/CD pipeline, or even the most reliable, 99.9% available product. It just needs to work to demonstrate value.

With all this said, I don't think the answer is just to AI vomit a whole product out. There are places where these solutions are truly good enough. I'll eventually write about this, but there's strategic nuance in figuring out what's worth street fighting vs what's worth over-engineering once you uncover and define more unknowns.
